/*****************************************************************************
 * LEMON v1.1                                                                *
 *                                                                           *
 * This file is part of the LEMON implementation of the SCIDAC LIME format.  *
 *                                                                           *
 * It is based directly upon the original c-lime implementation,             *
 * as maintained by C. deTar for the USQCD Collaboration,                    *
 * and inherits its license model and parts of its original code.            *
 *                                                                           *
 * LEMON is free software: you can redistribute it and/or modify             *
 * it under the terms of the GNU General Public License as published by      *
 * the Free Software Foundation, either version 3 of the License, or         *
 * (at your option) any later version.                                       *
 *                                                                           *
 * LEMON is distributed in the hope that it will be useful,                  *
 * but WITHOUT ANY WARRANTY; without even the implied warranty of            *
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the             *
 * GNU General Public License for more details. You should have received     *
 * a copy of the GNU General Public License along with LEMON. If not,        *
 * see <http://www.gnu.org/licenses/>.                                       *
 *                                                                           *
 * LEMON was written for the European Twisted Mass Collaboration.            *
 * For support requests or bug reports, please contact                       *
 *    A. Deuzeman (deuzeman@itp.unibe.ch)                                    *
 *****************************************************************************/

#pragma once

static void lemonSetupIOTypes(LemonSetup *setup, MPI_Comm cartesian, MPI_Offset siteSize, int const *latticeDims, int const *mapping)
{
  /* Gathering of the required MPI data from the cartesian communicator. */
  MPI_Comm_size(cartesian, &setup->size);
  MPI_Cartdim_get(cartesian, &setup->ndims);
  
  int *mpiCoords = (int*)malloc(setup->ndims * sizeof(int));
  int *mpiDims   = (int*)malloc(setup->ndims * sizeof(int));
  int *period    = (int*)malloc(setup->ndims * sizeof(int));
  MPI_Cart_get(cartesian, setup->ndims, mpiDims, period, mpiCoords);
  free(period);
  
  /* Determining the info of the lattice we are attempting to write out. */
  setup->starts = (int*)malloc(setup->ndims * sizeof(int));
  setup->strides = (int*)malloc(setup->ndims * sizeof(int));

  int *localDims = (int*)malloc(setup->ndims * sizeof(int));
  
  /* Calculation of local lattice dimensions from the MPI data we obtained. */
  for (int idx = 0; idx < setup->ndims; ++idx)
  {
    localDims[idx]       = latticeDims[idx] / mpiDims[idx];
    setup->starts[idx]   = 0;
    setup->strides[idx]  = (idx == 0) ? 1 : latticeDims[idx] * setup->strides[idx - 1];
  }

  free(mpiDims);
  free(mpiCoords);
  
  /* Allocate memory for the sequence of datatypes setting up the filetype. */
  setup->chain = (MPI_Datatype*)malloc(2 * setup->ndims * sizeof(MPI_Datatype));

  /* Elementary datatype for reading/writing: a single lattice site of the correct size.
     Note that we always assume we obtained this as raw binary data of the correct type,
     because apparently we cannot trust MPI libraries to deal with conversions internally. */
  MPI_Type_contiguous(siteSize, MPI_BYTE, setup->chain); /* i.e. the first element of chain... */
  MPI_Type_commit(setup->chain);

  /* Create a chain of vector types, recursively peeling of the dimensions */
  int ctr = 0;
  for (int dim = setup->ndims - 1; dim >= 0; --dim)
  {
    MPI_Type_vector(localDims[mapping[dim]], 1, setup->strides[mapping[dim]], setup->chain[ctr], &setup->chain[ctr + 1]);
    MPI_Type_commit(&setup->chain[ctr + 1]);
    ++ctr;
    MPI_Type_indexed(1, 1, setup->starts[mapping[dim]], setup->chain[ctr], &setup->chain[ctr + 1]);
    MPI_Type_commit(&setup->chain[ctr + 1]);
    ++ctr;
  }
  
  setup->etype = &setup->chain[0];
  setup->ftype = &setup->chain[ctr];
  
}